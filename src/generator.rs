use anyhow::Result;
use std::fs;
use std::path::PathBuf;
use walkdir::WalkDir;

use crate::config::SiteConfig;
use crate::content::ContentFile;
use crate::templates::TemplateEngine;
use crate::utils::{copy_dir_recursive, ensure_dir_exists, is_markdown_file, should_exclude};

pub struct SiteGenerator {
    source_dir: PathBuf,
    output_dir: PathBuf,
    config: SiteConfig,
    template_engine: TemplateEngine,
}

impl SiteGenerator {
    pub fn new(source_dir: &str, output_dir: &str, config: SiteConfig) -> Result<Self> {
        let source_path = PathBuf::from(source_dir);
        let output_path = PathBuf::from(output_dir);
        
        let template_engine = TemplateEngine::new(&source_path)?;

        Ok(SiteGenerator {
            source_dir: source_path,
            output_dir: output_path,
            config,
            template_engine,
        })
    }

    pub async fn build(&self) -> Result<()> {
        println!("🧹 Cleaning output directory...");
        if self.output_dir.exists() {
            fs::remove_dir_all(&self.output_dir)?;
        }
        fs::create_dir_all(&self.output_dir)?;

        println!("📁 Processing content files...");
        let content_files = self.collect_content_files()?;
        
        println!("📝 Rendering {} content files...", content_files.len());
        for content in &content_files {
            self.render_content_file(content).await?;
        }

        println!("📦 Copying static assets...");
        self.copy_static_assets()?;

        println!("🎨 Creating special files...");
        self.create_special_files().await?;

        Ok(())
    }

    fn collect_content_files(&self) -> Result<Vec<ContentFile>> {
        let mut content_files = Vec::new();
        let excludes = self.config.exclude.clone().unwrap_or_default();

        for entry in WalkDir::new(&self.source_dir)
            .into_iter()
            .filter_entry(|e| !should_exclude(e.path(), &excludes))
        {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() && (is_markdown_file(path) || path.extension().map(|e| e == "html").unwrap_or(false)) {
                if let Ok(content) = ContentFile::from_path(path, &self.source_dir) {
                    content_files.push(content);
                }
            }
        }

        Ok(content_files)
    }

    async fn render_content_file(&self, content: &ContentFile) -> Result<()> {
        let output_path = self.output_dir.join(content.get_file_path());
        ensure_dir_exists(&output_path)?;

        let rendered = self.template_engine.render_content(content, &self.config)?;
        fs::write(output_path, rendered)?;

        Ok(())
    }

    fn copy_static_assets(&self) -> Result<()> {
        let assets_src = self.source_dir.join("assets");
        if assets_src.exists() {
            let assets_dst = self.output_dir.join("assets");
            copy_dir_recursive(&assets_src, &assets_dst)?;
        }

        let special_files = [
            "manifest.json",
            "sw.js",
            "robots.txt",
            "sitemap.xml",
            "offline.html",
            ".nojekyll",
        ];

        for file in &special_files {
            let src = self.source_dir.join(file);
            let dst = self.output_dir.join(file);
            
            if src.exists() {
                fs::copy(src, dst)?;
            }
        }

        Ok(())
    }

    async fn create_special_files(&self) -> Result<()> {
        let nojekyll_path = self.output_dir.join(".nojekyll");
        let timestamp = chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC");
        fs::write(nojekyll_path, format!("# Generated by Rust Static Site Generator\n# Build time: {}\n", timestamp))?;

        let feed_content = format!(
            r#"<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>{}</title>
    <description>{}</description>
    <link>{}</link>
    <atom:link href="{}/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>{}</pubDate>
    <lastBuildDate>{}</lastBuildDate>
    <generator>Iacom Cuscuz Generator</generator>
  </channel>
</rss>"#,
            self.config.title.as_deref().unwrap_or("Iacom Cuscuz"),
            self.config.description.as_deref().unwrap_or("Simple static site"),
            self.config.url.as_deref().unwrap_or("https://iacomcuscuz.github.io"),
            self.config.url.as_deref().unwrap_or("https://iacomcuscuz.github.io"),
            chrono::Utc::now().format("%a, %d %b %Y %H:%M:%S %z"),
            chrono::Utc::now().format("%a, %d %b %Y %H:%M:%S %z"),
        );

        let feed_path = self.output_dir.join("feed.xml");
        fs::write(feed_path, feed_content)?;

        Ok(())
    }
}